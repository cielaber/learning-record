### 前端监控目标

**稳定性**

| 错误名称 | 备注                       |
| -------- | -------------------------- |
| JS错误   | JS执行错误或者promise      |
| 资源异常 | script、link等资源加载异常 |
| 接口错误 | ajax或fetch请求接口异常    |
| 白屏     | 页面空白                   |

**用户体验**

| 错误名称                                      | 备注                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| 加载时间                                      | 各个阶段的加载时间                                           |
| TTFB（Time Of First Byte，首字节时间）        | 指浏览器发起第一个请求到数据返回第一个字节所消耗的时间，这个时间包含了网络请求时间、后端处理时间等 |
| FP（First Paint，首次绘制）                   | 首次绘制包括了任何用户自定义的背景绘制，它是将第一个像素点绘制到屏幕的时刻 |
| FCP（First Content Paint，首次内容绘制）      | 首次内容绘制是浏览器将第一个DOM渲染到屏幕的时间，可以是任何文本、图像、SVG等的时间 |
| FMP（First Meaningful Paint，首次有意义绘制） | 首次有意义绘制是页面可用性的量度标准                         |
| FID（First Input Delay，首次输入延迟）        | 用户首次和页面交互到页面相应交互的时间                       |
| 卡顿                                          | 超过50ms的长任务                                             |

**业务**

| 错误名称       | 备注                             |
| -------------- | -------------------------------- |
| PV             | page view即页面浏览量或点击量    |
| UV             | 指访问某个站点的不同IP地址的人数 |
| 页面的停留时间 | 用户在每一个页面的停留时间       |

### 前端监控流程

- 前端埋点
- 数据上报
- 分析和计算：将采集到的数据进行加工汇总
- 可视化展示：将数据按各种维度进行展示
- 监控报警：发现问题后按一定的条件触发报警

![image-20230603184618668](./image-前端监控/image-20230603184618668.png)

#### 常见的埋点方案

##### 代码埋点

代码埋点就是以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时插入一段代码，保存这个监听行为或者将监听行为以某一种数据格式直接传递给服务端。

**优点**

- 可以在任意时刻，精准的发送或保存所需要的数据信息。

**缺点**

- 工作量大

##### 可视化埋点

通过可视化交互的手段，代替代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。

可视化埋点其实是用系统来代替手工插入埋点代码。

##### 无痕埋点

前端的任意一个事件都被绑定一个标识，所有事件都被记录下来。通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析。

**优点**

- 采集全量数据，不会出现漏埋和误埋等现象。

**缺点**

- 给数据传输和服务器增加压力
- 无法灵活定制数据结构

### 前端监控指标

#### JS异常监控

通过监听全局未捕获的错误。

```js
window.addEventListener('error', function (event) {}, true);
```

#### Promise异常监控

通过监听全局的`unhandledrejection`事件。

```js
window.addEventListener('unhandledrejection', function (event) {}, true)
```

#### JS、CSS资源文件加载异常监控

通过监听全局错误的`event.target`是否有`src`或者`href`属性来判断是否是文件加载错误。

```js
window.addEventListener('error', function (event) {
    if (event.target && (event.target.src || event.target.href)) {}
}, true);
```

#### 白屏检测

```js
/**
 * 白屏检测方法：关键点采样检测法
 * 原理：在页面有元素的方位选取点进行元素检测，这里采用以中心为基点的十字轴采样18个点，检测每个点对应的元素是否是原始的标签元素，如果是则认为该点是空白点，空白点达到阈值则发送白屏监控日志
 */

export function blankScreen() {
    // 关键点的元素是这些则认为是空白点
    let wrapperElements = ['html', 'body', '#container', '.content']
    let emptyPoints = 0;

    function getSelector(element) {
        if (element?.id) {
            return "#" + element.id;
        } else if (element?.className) {
            return "." + element.className.split(' ').filter(item => !!item).join('.')
        } else {
            return element?.nodeName.toLowerCase()
        }
    }
    function isWrapper(element) {
        let selector = getSelector(element)

        if (wrapperElements.indexOf(selector) != -1) {
            emptyPoints++;
        }
    }

    // 在页面onload事件完成后调用
    onload(function () {
        // 以中心为基点的横纵轴各取9个点作为采样点
        for (let i = 1; i <= 9; i++) {
            let xElement = document.elementFromPoint(window.innerWidth * i / 10, window.innerHeight / 2)
            let yElement = document.elementFromPoint(window.innerWidth / 2, window.innerHeight * i / 10)

            isWrapper(xElement)
            isWrapper(yElement)
        }
        // 空白点超过阈值发送日志
        if (emptyPoints >= 18) {
            let centerElement = document.elementFromPoint(window.innerWidth / 2, window.innerHeight / 2)
            tracker.send({
                kind: 'stability',
                type: 'blank',
                emptyPoints,
                screen: window.screen.width + "X" + window.screen.height,
                viewPoint: window.innerWidth + "X" + window.innerHeight,
                selector: getSelector(centerElement)
            })
        }
    })
}
```

#### 加载时间

![按获取文档记录的顺序列出时间戳的时间戳图](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming/timestamp-diagram.svg)

navigationStart：表示上一个文档卸载结束时的unix时间戳，如果没有上一个文档，则等于fetchStart。

unloadEventStart：表示前一个网页（与当前页面同域）unload的时间戳，如无前一个网页unloade或前一个网页与当前不同域，则为0。

unloadEventEnd: 返回前一个unload时间绑定的回调执行完毕的时间戳。

redirectStart：前一个Http重定向发送时的时间。有跳转且是同域名内重定向，否则为0。

redirectEnd：前一个Http重定向完成时的时间。有跳转且是同域名内重定向，否则为0。

fetchStart：浏览器准备使用http请求文档的时间，在检查本地缓存之前。

domainLookupStart/domainLookupEnd：DNS域名查询开始/结束的时间，如果使用本地缓存（则无需DNC查询）或持久链接，则和fetchStart一致。

connectStart：HTTP（TCP）开始或重新建立链接的时间，如果是持久链接，则和fetchStart一致。

connectEnd：HTTP（TCP）完成建立链接的时间（完成握手），如果是持久链接，则和fetchStart一致。

secureConnectionStart：Https链接开始的时间，如果不是安全链接则为0。

requestStart：http在建立链接之后，正式开始请求真实文档的时间，包括从本地读取缓存。

responseStart：http开始接收响应的时间（获取第一个字节），包括从本地读取缓存。

responseEnd：http响应接收完全的时间（最后一个字节），包括从本地读取缓存。

domLoading：开始解析渲染DOM树的时间。

domInteractive：完成解析DOM树的时间。

domContentLoadedEventStart：DOM解析完成后，页面内资源加载开始的时间。

domContentLoadedEventEnd：DOM解析完成后，网页内资源加载完成的时间（如js脚本加载执行完）

domComplete：DOM树解析完，资源也准备就绪。

loadEventStart：load事件发送给文档，即load函数开始执行时。

loadEventEnd：load函数执行完毕的时间。

参考：https://juejin.cn/post/7223280402475089978

| 字段             | 描述                     | 计算方式                                              | 意义                                                         |
| ---------------- | ------------------------ | ----------------------------------------------------- | ------------------------------------------------------------ |
| unload           | 前一个页面卸载耗时       | unloadEventEnd - unloadEventStart                     |                                                              |
| redirect         | 重定向耗时               | redirectEnd - redirectStart                           | 重定向的时间                                                 |
| appCache         | 缓存耗时                 | domainLookupStart - fetchStart                        | 读取缓存时间                                                 |
| dns              | DNS解析耗时              | domainLookupEnd - domainLookupStart                   | 可观察域名解析是否正常                                       |
| tcp              | TCP连接耗时              | connectEnd - connectStart                             | 建立连接耗时                                                 |
| ssl              | SSL安全耗时              | connectEnd - secureConnectionStart                    | 反映数据安全连接建立耗时                                     |
| ttfb             | Time To First Byte耗时   | responseStart - requestStart                          | 页面发出请求到接受到应答数据的第一个字节的耗时，反映服务器的处理能力 |
| response         | 响应数据传输耗时         | responseEnd - responseStart                           | 可用于观察网络是否正常                                       |
| dom              | DOM解析耗时              | domInteractive - responseEnd                          | 观察DOM结构是否合理，是否有JS阻塞页面解析                    |
| dcl              | DOMContentLoaded事件耗时 | domContentLoadedEventEnd - domContentLoadedEventStart | 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。（DOMContentLoaded 事件在html文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都执行完毕后触发。） |
| resources        | 资源加载耗时             | domComplete - domContentLoadedEventEnd                | 可观察文档流是否过大                                         |
| domReady         | DOM阶段渲染耗时          | domContentLoadedEventEnd - fetchStart                 |                                                              |
| 首次渲染耗时     | 首次渲染耗时             | responseEnd - fetchStart                              | 加载文档看到第一帧非空页面的时间，也叫白屏时间               |
| 首次可交互时间   | 首次可交互时间           | domInteractive - fetchStart                           | DOM解析完成时间，此时document.readyState为interactive        |
| 包首时间耗时     | 包首时间                 | responseStart - domainLookupStart                     | DNS解析到响应返回给浏览器第一个字节的时间                    |
| 页面完全加载时间 | 页面完全加载时间         | loadEventStart - fetchStart                           |                                                              |
| onLoad           | onLoad事件耗时           | loadEventEnd - loadEventStart                         |                                                              |

#### 性能指标

| 字段 | 描述                                     | 备注                                                         |
| ---- | ---------------------------------------- | ------------------------------------------------------------ |
| FP   | First Paint（首次绘制）                  | 包括了任何用户自定义的背景绘制，它是首先将像素绘制到屏幕的时刻。 |
| FCP  | First Content Paint（首次内容绘制）      | 是浏览器将第一个DOM渲染到屏幕的时间                          |
| FMP  | First Meaningful Paint（首次有意义绘制） | 页面有意义的内容渲染时间                                     |
| LCP  | Largest Contentful Paint（最大内容渲染） | 代表在viewport中最大的页面元素加载时间                       |
| DCL  | DomContentLoaded（DOM加载完成）          | 当HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，无需等待样式表、图像等资源加载 |
| L    | onLoad                                   | 当依赖的资源全部加载完毕后才会触发                           |
| TTI  | Time To Interactive（可交互时间）        | 用于标记应用已进行视觉渲染并可能靠响应用户输入的时间点       |
| FID  | First Input Delay（首次输入延迟）        | 用户首次和页面交互（单击链接、点击按钮等）到页面响应交互的时间 |

