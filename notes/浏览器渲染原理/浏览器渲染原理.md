# 浏览器渲染原理

### 渲染流程

#### 浏览器的五个进程

![image-20221120102531330](./image-浏览器渲染原理/image-20221120102531330.png)

- 浏览器进程：负责页面显示、用户交互、子进程管理、提供存储等。
- 渲染进程：每个页卡有单独的渲染进程，用于渲染页面。
- 网络进程：主要处理网络资源加载。
- GPU进程：动画、3D等的绘制、提高性能。
- 插件进程：处理插件。

#### 从输入URL到浏览器显示，页面发生了什么？

从进程角度：

- 用户输入url（如果输入关键字，会将关键字生成地址），开始导航，该过程发生在浏览器进程中。
- 浏览器进程会准备一个渲染进程用于渲染页面。
- 网络进程加载资源，最终加载的交给渲染进程处理。
- 渲染进程进行渲染。



从网络角度：

- 根据url，先去查找缓存，查找缓存是否过期，如果没过期则直接返回缓存内容。
- 如果没有缓存，需要发起请求。通过DNS协议，将域名解析成ip地址。
- 如果请求是HTTPS，则需要进行SSL协商。
- 根据ip地址来寻址，由于同一个域名最多能建立6个tcp连接，因此请求需要排队等待。
- tcp创建连接，传输数据。
- 浏览器根据服务响应的http状态码进行不同的操作。如接收到301、302响应，浏览器会根据重定向地址，重新进行新的网络请求。如果接受到304则会去查询浏览器缓存等等。



http历史：

- http 0.9：只负责传输html，最早没有请求头和响应头，无法传输文本之外的数据。
- http 1.0：提供了http header，可以根据不同的header处理不同的资源。
- http 1.1：默认开启keep-alive，保持连接，可以在一个tcp连接上进行多个http的请求，对链路进行了复用。但是每个域名仍可以同时建立6个tcp连接，但服务器处理请求是管线化的，会产生队头阻塞。
- http 2.0：用同一个tcp链接来发送数据，一个域名一个tcp连接，解决服务器队头阻塞问题。
- http 3.0：不再基于tcp，解决tcp的队头阻塞问题。



浏览器接受到资源后如何处理：

![image-20221120123929827](./image-浏览器渲染原理/image-20221120123929827.png)

- 浏览器无法直接使用HTML，需要将HTML转化成DOM树（document）。
- 浏览器无法解析纯文本的CSS样式，需要对CSS进行解析，解析成CSSOM（document.styleSheets）。
- 计算出DOM树中每个节点的具体样式（Attachment）。
- 创建渲染（布局）树，将DOM树中可见节点添加到布局树中，并结算节点渲染到页面的坐标位置。（layout）
- 通过布局树，进行分层（根据定位属性、透明属性、transform属性、clip属性等）生成图层树。
- 将不同图层进行绘制，转交给合成线程处理，最终生成页面并显示到浏览器上。（Painting、Display）

细化流程：

- 当服务器返回的类型是`text/html`时，浏览器会将收到的数据通过HTMLParse进行解析(边下载边解析)。
- 在解析前会进行预解析操作，会预先加载js、css等文件。
- 然后边解析html边生成DOM树。
- 遇到js时，HTMLPrase会停止解析，下载对应的js脚本并执行。
- 在执行js前，还需要等待当前脚本之上的所有css加载并解析完成(也就是说js依赖css的加载和解析完成)。
- js执行完毕后继续解析剩下的html。

![image-20221120143410622](./image-浏览器渲染原理/image-20221120143410622.png)